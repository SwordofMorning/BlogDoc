[toc]

&emsp;&emsp;在上一章中，我们介绍了各种保护线程间共享数据的方法。下面我们要介绍在线程上进行同步操作。例如，一个线程在其完成任务之前可能需要等待另一个线程。C++STL提供了**条件变量（Condition Variables）**和**期值（future）**来实现线程间的同步操作。

## 一、等待事件或其他条件

&emsp;&emsp;假设我们现在在乘坐夜间列车。为了确保能在正确的站点下车，我们又以下几种做法：通宵保持清醒，注意下车的地方；预估一个火车到站的时间，然后去睡觉；让一个人或东西在火车到站的时候叫醒我们。同样的，在线程之间的等待也有这种关系。

&emsp;&emsp;首先，该线程可以一直检查（由Mutex保护的）共享数据的标识，并且让第二个线程在完成任务时设置该标识。这种做法在等待上浪费了时间，不值得推荐。

&emsp;&emsp;第二个选择是使用std::this_thread::sleep_for()函数，让等待中的线程休眠一会儿：

```cpp
bool flag;
std::mutex m;

void wait_for_flag()
{
    std::unique_lock<std::mutex> lk(m);

    while(!flag)
    {
        lk.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        lk.lock();
    }
}
```

&emsp;&emsp;第三个选择，是使用STL提供的等待工具来实现，下面我们先介绍条件变量的使用方法。

### 1.1 用条件变量等待

&emsp;&emsp;标准库提供了两个调教变量的实现：std::condition_variable和std::condition_variable_any。二者均定义在&lt;condition_variable&gt;中，两者都需要同互斥元一起工作。前者仅限于和std::mutex一起，后者则可以与**符合成为类似互斥元的最低标准的任何东西**一起工作。

&emsp;&emsp;下面我们来看一个例子：假设我们有两个线程，preparation和processing，它们通过一个队列来实现通信：

```cpp
std::mutex dataMutex;
std::queue<data> dataQue;
std::condition_variable dataCond;

void data_Preparation_Thread()
{
    while(more_data_to_prepare())
    {
        data pData = prepare_data();

        // 锁定后装入数据
        std::lock_guard<std::mutex> lk(dataMutex);

        dataQue.push(pData);

        // 通知等待中的线程
        dataCond.notify_once();
    }
}

void data_Processing_Thread()
{
    while(true)
    {
        // 这里使用unique_lock，而非lock_guard，下面详细解释
        std::unique_lock<std::mutex> lk(dataMutex);

        dataCond.wait(lk,
                    []{return !dataQue.empty();});
        
        data head = dataQue.front();
        dataQue.pop();

        // 解锁后处理数据，以提高并发性能
        lk.unlock();
        process(head);

        if (isLastData(head))   break;
    }
}
```

&emsp;&emsp;在上面的wait()中，我们第一个参数是锁对象lk(dataMutex)，第二个参数是一个Lambda形式的可调用对象。进入加工函数首先锁定互斥元，如果Lambda返回true，wait()则返回，互斥元仍然被锁定；如果Lambda返回false，wait()解锁互斥元并将线程置于阻塞或等待状态。当来自数据准备线程中对notify_once()的调用通知条件变量时，加工线程解除阻塞，并重新判断。

&emsp;&emsp;在上面的过程中，我们需要不断的对锁对象进行加锁解锁，所以我们应该使用更具灵活性的unique_lock而不是lock_guard。后者的解锁只能在其析构时解锁。

&emsp;&emsp;值得注意的是，在上面的一套操作中，条件变量通知另一个线程并非直接唤醒它，而是唤醒再次进行判断。

### 1.2 使用条件变量构造线程安全的队列

