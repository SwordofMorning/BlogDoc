[toc]

&emsp;&emsp;在上一章中，我们介绍了各种保护线程间共享数据的方法。下面我们要介绍在线程上进行同步操作。例如，一个线程在其完成任务之前可能需要等待另一个线程。C++STL提供了**条件变量（Condition Variables）**和**期值（future）**来实现线程间的同步操作。

## 一、等待事件或其他条件

&emsp;&emsp;假设我们现在在乘坐夜间列车。为了确保能在正确的站点下车，我们又以下几种做法：通宵保持清醒，注意下车的地方；预估一个火车到站的时间，然后去睡觉；让一个人或东西在火车到站的时候叫醒我们。同样的，在线程之间的等待也有这种关系。

&emsp;&emsp;首先，该线程可以一直检查（由Mutex保护的）共享数据的标识，并且让第二个线程在完成任务时设置该标识。这种做法在等待上浪费了时间，不值得推荐。

&emsp;&emsp;第二个选择是使用std::this_thread::sleep_for()函数，让等待中的线程休眠一会儿：

```cpp
bool flag;
std::mutex m;

void wait_for_flag()
{
    std::unique_lock<std::mutex> lk(m);

    while(!flag)
    {
        lk.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        lk.lock();
    }
}
```

&emsp;&emsp;第三个选择，是使用STL提供的等待工具来实现，下面我们先介绍条件变量的使用方法。

### 1.1 用条件变量等待

&emsp;&emsp;标准库提供了两个调教变量的实现：std::condition_variable和std::condition_variable_any。二者均定义在&lt;condition_variable&gt;中，两者都需要同互斥元一起工作。前者仅限于和std::mutex一起，后者则可以与**符合成为类似互斥元的最低标准的任何东西**一起工作。

&emsp;&emsp;下面我们来看一个例子：假设我们有两个线程，preparation和processing，它们通过一个队列来实现通信：

```cpp
std::mutex dataMutex;
std::queue<data> dataQue;
std::condition_variable dataCond;

void data_Preparation_Thread()
{
    while(more_data_to_prepare())
    {
        data pData = prepare_data();

        // 锁定后装入数据
        std::lock_guard<std::mutex> lk(dataMutex);

        dataQue.push(pData);

        // 通知等待中的线程
        dataCond.notify_one();
    }
}

void data_Processing_Thread()
{
    while(true)
    {
        // 这里使用unique_lock，而非lock_guard，下面详细解释
        std::unique_lock<std::mutex> lk(dataMutex);

        dataCond.wait(lk,
                    []{return !dataQue.empty();});
        
        data head = dataQue.front();
        dataQue.pop();

        // 解锁后处理数据，以提高并发性能
        lk.unlock();
        process(head);

        if (isLastData(head))   break;
    }
}
```

&emsp;&emsp;在上面的wait()中，我们第一个参数是锁对象lk(dataMutex)，第二个参数是一个Lambda形式的可调用对象。进入加工函数首先锁定互斥元，如果Lambda返回true，wait()则返回，互斥元仍然被锁定；如果Lambda返回false，wait()解锁互斥元并将线程置于阻塞或等待状态。当来自数据准备线程中对notify_one()的调用通知条件变量时，加工线程解除阻塞，并重新判断。

&emsp;&emsp;在上面的过程中，我们需要不断的对锁对象进行加锁解锁，所以我们应该使用更具灵活性的unique_lock而不是lock_guard。后者的解锁只能在其析构时解锁。

&emsp;&emsp;值得注意的是，在上面的一套操作中，条件变量通知另一个线程并非直接唤醒它，而是唤醒再次进行判断。

### 1.2 使用条件变量构造线程安全的队列

&emsp;&emsp;对于上面的例子，我们可以编写一个线程安全的deque，将队列empty()与否的的判断放入deque中，这样在两个线程中就不用进行判断了。

```cpp
#include <queue>
#include <mutex>
#include <condition_variable>

template<typename T>
class theradsafeQueue
{
private:
    std::mutex m_mutex;
    std::queue<T> m_queue;
    std::condition_variable m_cond;
public:
    void push(T ins)
    {
        std::lock_guard<std::mutex> lk(m_mutex);
        m_queue.push(ins);
        m_cond.notify_one();
    }

    void wait_and_pop(T& val)
    {
        std::unique_lock<std::mutex> lk(m_mutex);
        m_cond.wait(
            lk,
            [this]{ return !m_queue.empty(); }
        );

        val = m_queue.front();
        data_queue.pop();
    }
};

theradsafeQueue dataQue;

void data_Preparation_Thread()
{
    while(more_data_to_prepare())
    {
        data pData = prepare_data();

        dataQue.push(pData);
    }
}

void data_Processing_Thread()
{
    while(true)
    {   
        data head;
        dataQue.wait_and_pop(head);

        process(head);

        if (isLastData(head))   break;
    }
}
```

&emsp;&emsp;如果是多个线程等待一个线程的情况，我们可以直接使用notify_all()。wait()会一直等待notify，如果线程只打算等待一次，那么可以使用future。

## 二、使用future等待一次性事件

&emsp;&emsp;假设我们要乘坐飞机，当我们抵达机场并完成了各种手续之后仍然需要等待一定时间。我们有各种各样的方式来等待，比如看书、上网或者喝咖啡，但是我们只会等待一次（这个特定的）航班。C++使用future来实现这种一次性的等待。如果一个线程需要等待特定的一次性事件，那么他就会获取一个future来表示该事件。然后，线程可以周期性地在这个future上等待一小段时间，以检查时间是否发生，而在检查间隙执行其他任务。另外，该线程还可以去执行其他任务，直到所需的事件已经发生了才继续进行，随后future变为ready。一旦事件已经发生（future变为ready），future便无法复位。

&emsp;&emsp;STL中有两种future，二者均包含在头文件&lt;future&gt;中，std::unique_future和std::shared_future，二者仿造智能指针设计。