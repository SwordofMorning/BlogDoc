[toc]

&emsp;&emsp;在使用多线程编程的时候，我们需要注意线程之间共享数据的问题，这种问题基本上是对统一数据同时读写造成的，详细情况可以参考**计算机操作系统**，这里不多赘述。为了避免这种情况，我们可以使用几种方法来解决，一是给数据上**锁**（互斥元，mutex），这是本章的内容；二是**无锁编程**（lock-free programming），这将在后面的章节中讨论；还有一种方式是将对数据结构的操作更新为一个**事务**（transaction）。

## 一、使用互斥元保护共享数据

&emsp;&emsp;这里我们不过多介绍mutex的设计思想，我们主要介绍其在C++中的使用。

### 1.1 在C++中使用mutex

&emsp;&emsp;在C++中，通过构造std::mutex的实例创建互斥元，调用成员函数lock()来锁定它，调用成员函数unlock()来结果它。然而，直接调用成员函数是不推荐的做法，因为我们需要在函数*包括异常在内*的每个出口都调用unlock()。作为替代，STL提供来std::lock_guard类模板，实现了互斥元的RAII惯用语法；它在构造时锁定所给的互斥元，在析构时解锁所给的互斥元。下面是一个演示，std::mutex和std::lock_guard()都声明于&lt;mutex&gt;。

```cpp
#include <list>
#include <mutex>
#include <algorithm>

std::list<int> some_list;
std::mutex some_mutex;

// 向链表中添加元素
void add_to_list(int val)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    some_list.push_back(val);
}

// 查找元素val是否在链表中
bool list_contains(int val)
{
    std::lock_guard<std::mutex> guard(some_mutex);

    return std::find(some_list.begin(), some_list.end(), val) 
        != some_list.end();
}
```

&emsp;&emsp;在上面的代码中，我们使用了一个全局mutex来对列表实施来保护。在通常的使用中，我们可以将它封装到一个类中，以private的形势来避免冲突。但值得注意的是，**传递引用和指针可能会造成越过mutex的情况**，下面来看一段糟糕的代码：

```cpp
/* ===== class : 数据类 ===== */
class data
{
private:
    int m_a;
public: 
    void DoSth();
}

/* ===== class : 封装数据类 ===== */
class data_wrapper
{
private:
    data m_data;
    std::mutex m_dataMutex;
public:
    template<typename Function>
    void ProcessData(Function func)
    {
        // 传递“受保护”的数据到func
        std::lock_guard<std::mutex> guard(m_dataMutex);
        func(m_data);
    }
}

data* unprotectedData;

// 一个恶意函数，用于获取data_wrapper中的&m_data
void malicious_func(data& protectedData)
{
    unprotectedData = & protectedData;
}

data_warpper dw;

void foo()
{
    dw.process_data(malicious_func);
    // unpData已经或得了data的引用，现在可以绕开mutex直接使用doSth
    unprotectedData->DoSth();
}
```

&emsp;&emsp;在上面的的代码中，我们通过foo，向data_wrapper传入一个恶意函数，或得了其m_data的引用。而获得了data的unprotectedData就可以绕过mutex无需锁定互斥元即可调用DoSth。所以，我们应当注意**不要将受保护数据的指针和引用传递到锁的范围之外，无论是从函数中返回它们、将其存放在外部可见的内存中，还是作为参数传递给用户提供的函数**。

### 1.2 发现接口中固有的竞争条件

&emsp;&emsp;回忆下我们的第一段代码，我们对一个list整体添加了保护，而不是对其中的每一个节点添加保护。如果是后者的话，我们在删除节点的时候仍然可能面对竞争问题。下面我们来看另一个例子，